# P0.4 — Reporting Minimal Exploitable

## Vision
Rendre chaque vue temporelle (Journée / 7j / 30j / Année) **auto-explicative**, cohérente, et "manager comprend en 10 sec".

## Décomposition en tickets

---

# TICKET 1 : ReportingEngine + Domain Models (fondations)

## Title
**Créer ReportingEngine + standardiser formatage cross-vues**

## Description
Créer un **domain layer** centralisé pour calcul et formatage des métriques, éliminant toute logique métier dispersée dans les vues. Le ReportingEngine expose des modèles riches (`ReportingSummary`, `ReportingDelta`) pré-formatés, prêts à render.

## Scope (fichiers/areas)

### 1. `Services/ReportingEngine.swift` (NOUVEAU)
```swift
/// Domain layer pour reporting cross-vues
final class ReportingEngine {
    
    // MARK: - Public API
    
    /// Génère un résumé complet pour une période
    static func makeSummary(
        snapshot: MetricsSnapshot,
        maxCapacity: Int
    ) -> ReportingSummary
    
    /// Calcule les deltas vs période précédente
    static func makeDelta(
        comparison: MetricsComparison
    ) -> ReportingDelta?
    
    /// Calcule la période précédente (même durée, shifted)
    static func previousRange(for range: TimeRange) -> TimeRange
    
    /// Détermine le statut global (OK/Data issue/Stale/Missing)
    static func computeStatus(
        snapshot: MetricsSnapshot
    ) -> ReportingStatus
}
```

### 2. `Models/ReportingSummary.swift` (NOUVEAU)
```swift
/// Résumé formaté ready-to-display
struct ReportingSummary {
    // Bloc "Résumé rapide"
    let totalEntries: String           // "1,234"
    let avgOccupancyPercent: String    // "72.3%"
    let peakOccupancy: String          // "95"
    let peakTimestamp: String?         // "14 janv · 22h15"
    let netChange: String              // "+342" ou "−12"
    
    // Bloc "Couverture/Qualité"
    let coveragePeriod: String         // "10:07–14:29"
    let status: ReportingStatus
    let daysCovered: String?           // "7 jours" (nil si Journée)
    
    // Bloc "Détails" - Table Couverture
    let totalEvents: String            // "2,456"
    let totalEntriesIn: String         // "1,234"
    let totalExits: String             // "1,222"
    let avgEntriesPerDay: String?      // "176.3" (nil si Journée)
    
    // Raw values (pour charts, etc.)
    let rawAvgOccupancy: Double
    let rawPeakCount: Int
    let rawNetChange: Int
}

enum ReportingStatus {
    case ok
    case dataIssue(reason: String)     // Hard integrity issues
    case stale(reason: String)          // Coverage gaps, staleness
    case missing(reason: String)        // No data
    
    var displayText: String
    var color: Color  // Nexus.Colors...
    var icon: String
}
```

### 3. `Models/ReportingDelta.swift` (NOUVEAU)
```swift
/// Deltas vs période précédente (formaté, anti-ambiguïté)
struct ReportingDelta {
    // Entrées
    let entriesDelta: String           // "↓ 85"
    let entriesPercentChange: String?  // "(−6.1%)" ou nil si N/A
    
    // Occupation moyenne
    let avgOccupancyDelta: String      // "↓ 0.2 pts"
    
    // Pic d'occupation
    let peakCountDelta: String         // "↓ 5"
    
    // Règle: jamais "— 0", afficher "0" ou "N/A"
    var isComparable: Bool  // false si données insuffisantes
}
```

### 4. `Extensions/FormatHelpers.swift` (NOUVEAU)
```swift
/// Helpers de formatage (DRY)
extension Int {
    func formatted() -> String  // "1,234"
    func formattedWithSign() -> String  // "+342" ou "−12"
}

extension Double {
    func formattedPercent(decimals: Int = 1) -> String  // "72.3%"
    func formattedPoints(decimals: Int = 1) -> String   // "0.2 pts"
}

extension Date {
    func formattedForReport(style: ReportDateStyle) -> String
}

enum ReportDateStyle {
    case peakTimestamp     // "14 janv · 22h15"
    case coveragePeriod    // "10:07–14:29"
    case dayMonth          // "14 janv"
}
```

## Acceptance Criteria

### AC1 : ReportingEngine génère summary cohérent
- [ ] `makeSummary()` retourne `ReportingSummary` complet
- [ ] Tous les champs formatés selon spécification (voir P0.4 scope)
- [ ] `%` à 1 décimale, Net avec signe explicite
- [ ] Tests unitaires : vérifie formatage sur cas nominal + edge cases

### AC2 : ReportingDelta gère ambiguïtés
- [ ] Si période précédente a 0 entrées → `entriesPercentChange = nil`, pas "N/A"
- [ ] Jamais afficher "— 0", toujours "0" ou nil
- [ ] Delta occupancy toujours en **points** (pas %)
- [ ] Tests : vérifie "divide by zero", période vide, etc.

### AC3 : Status computation robuste
- [ ] `.dataIssue` si `hasHardIntegrityIssues` (P0.1.1)
- [ ] `.stale` si coverage gaps > seuil
- [ ] `.missing` si 0 données
- [ ] `.ok` sinon
- [ ] Tests : vérifie priorité (dataIssue > stale > missing)

### AC4 : Formatage uniforme (DRY)
- [ ] Helpers centralisés dans `FormatHelpers.swift`
- [ ] Pas de duplication de logique de formatage dans les vues
- [ ] Locale fr_FR partout
- [ ] Tests : vérifie nombres grands (1M+), négatifs, 0

## Edge Cases

1. **Période avec 0 événements**
   - totalEntries = "0", avgOccupancy = "0.0%", status = `.missing`

2. **Période précédente vide (delta N/A)**
   - `isComparable = false`, tous les delta = nil

3. **Pic multiple (égalité)**
   - Utiliser premier timestamp (déjà dans MetricsCalculator)

4. **Net change = 0**
   - Afficher "0", pas "+0" ni "—"

5. **Grandes valeurs (> 1M)**
   - Formatter avec séparateurs : "1,234,567"

---

# TICKET 2 : UI "Résumé rapide" unifié (cross-vues)

## Title
**Standardiser bloc "Résumé rapide" sur toutes les vues temporelles**

## Description
Créer un component réutilisable `ReportSummaryCard` qui affiche les 4 KPI clés de manière identique sur Journée / 7j / 30j / Année. Utilise `ReportingSummary` du ticket 1.

## Scope (fichiers/areas)

### 1. `Views/Components/ReportSummaryCard.swift` (NOUVEAU)
```swift
struct ReportSummaryCard: View {
    let summary: ReportingSummary
    
    var body: some View {
        VStack(spacing: Nexus.Spacing.md) {
            SectionHeader(title: "Résumé rapide")
            
            LazyVGrid(columns: [
                GridItem(.flexible(), spacing: Nexus.Spacing.md),
                GridItem(.flexible(), spacing: Nexus.Spacing.md)
            ], spacing: Nexus.Spacing.md) {
                // KPI 1: Total entrées
                MetricCard(
                    title: "Total entrées",
                    value: summary.totalEntries,
                    size: .large
                )
                
                // KPI 2: Occupation moyenne
                MetricCard(
                    title: "Occupation moy.",
                    value: summary.avgOccupancyPercent,
                    size: .large
                )
                
                // KPI 3: Pic d'occupation
                MetricCard(
                    title: "Pic d'occupation",
                    value: summary.peakOccupancy,
                    subtitle: summary.peakTimestamp,
                    size: .medium
                )
                
                // KPI 4: Variation nette
                MetricCard(
                    title: "Variation nette",
                    value: summary.netChange,
                    valueColor: Nexus.Colors.delta(summary.rawNetChange),
                    size: .medium
                )
            }
        }
    }
}
```

### 2. `Views/DashboardView.swift` (MODIFIER)
- Intégrer `ReportSummaryCard` pour période "Journée" (offset != 0)
- Remplacer logique actuelle par simple `ReportSummaryCard(summary: viewModel.reportSummary)`

### 3. `Views/HistoryView.swift` (MODIFIER)
- Remplacer `heroKPIsSection()` + `summarySection()` par `ReportSummaryCard`
- Uniformiser avec DashboardView

### 4. `ViewModels/DashboardViewModel.swift` (MODIFIER)
```swift
// Ajouter computed property
var reportSummary: ReportingSummary? {
    guard let snapshot = currentSnapshot else { return nil }
    return ReportingEngine.makeSummary(
        snapshot: snapshot,
        maxCapacity: maxCapacity
    )
}
```

### 5. `ViewModels/HistoryViewModel.swift` (MODIFIER)
```swift
// Ajouter computed property
var reportSummary: ReportingSummary? {
    guard let snapshot = currentSnapshot else { return nil }
    return ReportingEngine.makeSummary(
        snapshot: snapshot,
        maxCapacity: location?.maxCapacity ?? 100
    )
}
```

## Acceptance Criteria

### AC1 : Component réutilisable
- [ ] `ReportSummaryCard` fonctionne avec `ReportingSummary` seul
- [ ] Pas de dépendance à DashboardViewModel ou HistoryViewModel
- [ ] Preview standalone fonctionne

### AC2 : Affichage identique cross-vues
- [ ] Même layout (2x2 grid)
- [ ] Mêmes titres, même formatage
- [ ] Même couleurs (delta net avec Nexus.Colors.delta)
- [ ] Validation visuelle : screenshot "Journée" ≈ "7j" ≈ "30j" ≈ "Année"

### AC3 : Gestion états vides
- [ ] Si summary = nil → afficher skeleton loader
- [ ] Si totalEntries = 0 → afficher "0" (pas "—")
- [ ] Si peakTimestamp = nil → subtitle vide (pas de crash)

### AC4 : Responsive
- [ ] Fonctionne sur iPhone SE (petit écran)
- [ ] Fonctionne sur iPad (grand écran)
- [ ] Grid s'adapte correctement

## Edge Cases

1. **Période sans données**
   - Afficher "0" partout, pas d'erreur

2. **Pic sans timestamp (impossible normalement)**
   - Afficher pic sans subtitle

3. **Net change très grand (> 10,000)**
   - Formatter avec séparateurs, pas de débordement UI

---

# TICKET 3 : UI "Couverture/Qualité" + "Détails" (tables)

## Title
**Standardiser blocs "Couverture/Qualité" + "Détails" avec tables cross-vues**

## Description
Créer components `ReportQualityCard` et `ReportDetailsCard` pour afficher couverture, statut global, et tables détaillées. Utilise `ReportingSummary` + `ReportingStatus`.

## Scope (fichiers/areas)

### 1. `Views/Components/ReportQualityCard.swift` (NOUVEAU)
```swift
struct ReportQualityCard: View {
    let summary: ReportingSummary
    
    var body: some View {
        VStack(spacing: Nexus.Spacing.sm) {
            SectionHeader(title: "Couverture / Qualité")
            
            VStack(spacing: 0) {
                // Période couverte
                dataRow(
                    label: "Période couverte",
                    value: summary.coveragePeriod
                )
                
                NexusDivider()
                
                // Jours couverts (multi-jours uniquement)
                if let days = summary.daysCovered {
                    dataRow(
                        label: "Jours couverts",
                        value: days
                    )
                    NexusDivider()
                }
                
                // Statut global
                statusRow(status: summary.status)
            }
            .padding(Nexus.Spacing.md)
            .nexusCard()
        }
    }
    
    private func statusRow(status: ReportingStatus) -> some View {
        HStack {
            Text("Statut global")
                .font(Nexus.Typography.body)
                .foregroundColor(Nexus.Colors.textSecondary)
            Spacer()
            HStack(spacing: Nexus.Spacing.xs) {
                Image(systemName: status.icon)
                    .foregroundColor(status.color)
                Text(status.displayText)
                    .foregroundColor(status.color)
            }
            .font(Nexus.Typography.bodyEmphasis)
        }
        .padding(.vertical, Nexus.Spacing.sm)
    }
}
```

### 2. `Views/Components/ReportDetailsCard.swift` (NOUVEAU)
```swift
struct ReportDetailsCard: View {
    let summary: ReportingSummary
    
    var body: some View {
        VStack(spacing: Nexus.Spacing.md) {
            // Table Couverture
            coverageTable
            
            // Table Occupation
            occupancyTable
        }
    }
    
    private var coverageTable: some View {
        VStack(spacing: Nexus.Spacing.sm) {
            SectionHeader(title: "Couverture (détails)")
            
            VStack(spacing: 0) {
                dataRow(label: "Événements totaux", value: summary.totalEvents)
                NexusDivider()
                dataRow(label: "Entrées", value: summary.totalEntriesIn)
                NexusDivider()
                dataRow(label: "Sorties", value: summary.totalExits)
                NexusDivider()
                dataRow(
                    label: "Variation nette",
                    value: summary.netChange,
                    valueColor: Nexus.Colors.delta(summary.rawNetChange)
                )
                
                // Moy entrées/jour (multi-jours uniquement)
                if let avg = summary.avgEntriesPerDay {
                    NexusDivider()
                    dataRow(label: "Moy. entrées/jour", value: avg)
                }
            }
            .padding(Nexus.Spacing.md)
            .nexusCard()
        }
    }
    
    private var occupancyTable: some View {
        VStack(spacing: Nexus.Spacing.sm) {
            SectionHeader(title: "Occupation (détails)")
            
            VStack(spacing: 0) {
                dataRow(label: "Occupation moyenne", value: summary.avgOccupancyPercent)
                NexusDivider()
                dataRow(label: "Pic d'occupation", value: summary.peakOccupancy)
                
                if let timestamp = summary.peakTimestamp {
                    NexusDivider()
                    dataRow(label: "Moment du pic", value: timestamp)
                }
            }
            .padding(Nexus.Spacing.md)
            .nexusCard()
        }
    }
}
```

### 3. Intégrer dans `DashboardView.swift` et `HistoryView.swift`
- Remplacer sections existantes par components

## Acceptance Criteria

### AC1 : Qualité affichée correctement
- [ ] Période couverte formatée (ex: "10:07–14:29")
- [ ] Jours couverts visible uniquement si multi-jours (7j/30j/Année)
- [ ] Statut avec icône + couleur selon ReportingStatus

### AC2 : Tables détaillées complètes
- [ ] Table Couverture : 4 lignes fixes + 1 conditionnelle (moy/jour)
- [ ] Table Occupation : 2 lignes fixes + 1 conditionnelle (moment pic)
- [ ] Formatage nombres cohérent (séparateurs, signes)

### AC3 : Statut priorité correcte
- [ ] dataIssue affiché en priorité (rouge)
- [ ] stale ensuite (orange)
- [ ] missing ensuite (gris)
- [ ] ok par défaut (vert)

## Edge Cases

1. **Période Journée (pas de jours couverts)**
   - Ligne "Jours couverts" cachée

2. **Pic sans timestamp**
   - Ligne "Moment du pic" cachée

3. **Moy entrées/jour = 0.0**
   - Afficher "0.0", pas de masquage

---

# TICKET 4 : UI "Vs période précédente" (anti-ambiguïté)

## Title
**Standardiser bloc comparaison "Vs période précédente" (règles anti-ambiguïté)**

## Description
Créer component `ReportComparisonCard` qui affiche deltas vs période précédente de manière non ambiguë. Implémente règle "jamais '— 0', afficher '0' ou 'N/A'".

## Scope (fichiers/areas)

### 1. `Views/Components/ReportComparisonCard.swift` (NOUVEAU)
```swift
struct ReportComparisonCard: View {
    let delta: ReportingDelta?
    
    var body: some View {
        VStack(spacing: Nexus.Spacing.sm) {
            SectionHeader(title: "vs. Période précédente")
            
            if let delta = delta, delta.isComparable {
                VStack(spacing: 0) {
                    // Entrées
                    comparisonRow(
                        label: "Entrées",
                        delta: delta.entriesDelta,
                        percent: delta.entriesPercentChange
                    )
                    
                    NexusDivider()
                    
                    // Occupation moyenne
                    comparisonRow(
                        label: "Occupation moy.",
                        delta: delta.avgOccupancyDelta,
                        percent: nil  // Pas de % pour pts
                    )
                    
                    NexusDivider()
                    
                    // Pic d'occupation
                    comparisonRow(
                        label: "Pic d'occupation",
                        delta: delta.peakCountDelta,
                        percent: nil
                    )
                }
                .padding(Nexus.Spacing.md)
                .nexusCard()
            } else {
                notComparableView
            }
        }
    }
    
    private func comparisonRow(label: String, delta: String, percent: String?) -> some View {
        HStack {
            Text(label)
                .font(Nexus.Typography.body)
                .foregroundColor(Nexus.Colors.textSecondary)
            
            Spacer()
            
            HStack(spacing: Nexus.Spacing.xs) {
                Text(delta)
                    .font(Nexus.Typography.bodyMono)
                
                if let pct = percent {
                    Text(pct)
                        .font(Nexus.Typography.micro)
                        .foregroundColor(Nexus.Colors.textTertiary)
                }
            }
            // Couleur selon signe du delta
            .foregroundColor(deltaColor(from: delta))
        }
        .padding(.vertical, Nexus.Spacing.sm)
    }
    
    private var notComparableView: some View {
        VStack(spacing: Nexus.Spacing.sm) {
            Image(systemName: "chart.line.flattrend.xyaxis")
                .font(.system(size: 24))
                .foregroundColor(Nexus.Colors.textDisabled)
            
            Text("Données insuffisantes pour comparaison")
                .font(Nexus.Typography.caption)
                .foregroundColor(Nexus.Colors.textTertiary)
        }
        .frame(maxWidth: .infinity, minHeight: 100)
        .nexusCard()
    }
    
    private func deltaColor(from text: String) -> Color {
        if text.contains("↑") || text.hasPrefix("+") {
            return Nexus.Colors.positive
        } else if text.contains("↓") || text.hasPrefix("−") {
            return Nexus.Colors.negative
        } else {
            return Nexus.Colors.textPrimary  // Neutre pour 0
        }
    }
}
```

### 2. `ViewModels` : Ajouter computed property
```swift
var reportDelta: ReportingDelta? {
    guard let comparison = comparison else { return nil }
    return ReportingEngine.makeDelta(comparison: comparison)
}
```

### 3. Intégrer dans vues

## Acceptance Criteria

### AC1 : Deltas formatés correctement
- [ ] Entrées : "↓ 85 (−6.1%)" ou "↑ 12 (+3.2%)"
- [ ] Occupation : "↓ 0.2 pts" (jamais %)
- [ ] Pic : "↓ 5" ou "0" (pas "—")

### AC2 : Règle anti-ambiguïté respectée
- [ ] Si delta = 0 → afficher "0", pas "+0" ni "−0"
- [ ] Si N/A (période vide) → `isComparable = false` + vue "non comparable"
- [ ] Jamais afficher "N/A" dans les valeurs, masquer la card entière

### AC3 : Couleurs sémantiques
- [ ] ↑ ou + → vert (positive)
- [ ] ↓ ou − → rouge (negative)
- [ ] 0 → neutre (textPrimary)

### AC4 : Vue "non comparable"
- [ ] Affichée si `delta = nil` ou `isComparable = false`
- [ ] Message explicite : "Données insuffisantes pour comparaison"
- [ ] Icône neutre (pas d'erreur)

## Edge Cases

1. **Période précédente vide**
   - `isComparable = false`, afficher vue "non comparable"

2. **Delta = 0 pour tous**
   - Afficher "0" partout, couleur neutre

3. **Entrées +12 mais % impossible (période précédente = 0)**
   - Afficher "↑ 12" sans "(+X%)"

---

# ORDRE D'EXÉCUTION RECOMMANDÉ

## Phase 1 : Fondations (Ticket 1)
**Priorité** : BLOQUANT pour tickets 2/3/4
**Durée estimée** : 3-4h
1. Créer `ReportingEngine` + domain models
2. Créer `FormatHelpers`
3. Tests unitaires (formatage, edge cases)

## Phase 2 : UI par blocs (Tickets 2/3/4 en parallèle possible)
**Priorité** : ÉGALE (peuvent être faits en parallèle par différentes personnes)
**Durée estimée** : 2-3h chacun

### Ticket 2 : Résumé rapide
- Créer `ReportSummaryCard`
- Intégrer dans DashboardView + HistoryView

### Ticket 3 : Qualité + Détails
- Créer `ReportQualityCard` + `ReportDetailsCard`
- Intégrer dans vues

### Ticket 4 : Comparaison
- Créer `ReportComparisonCard`
- Intégrer dans vues

## Phase 3 : Polish (après 2/3/4)
- Tests manuels cross-vues
- Vérification cohérence visuelle
- Edge cases validation

---

# DEFINITION OF DONE GLOBALE P0.4

## ✅ DoD (4-6 bullets)

1. **Cohérence cross-vues** :
   - [ ] Même layout "Résumé rapide" sur Journée/7j/30j/Année
   - [ ] Même formatage (séparateurs, décimales, signes)
   - [ ] Même couleurs sémantiques (delta vert/rouge, statut)

2. **Anti-ambiguïté** :
   - [ ] Jamais "— 0", toujours "0" ou masqué
   - [ ] Delta occupancy en **points**, pas %
   - [ ] Période non comparable → vue explicite "Données insuffisantes"

3. **Qualité technique** :
   - [ ] Aucune logique métier dans les vues (tout dans ReportingEngine)
   - [ ] Components réutilisables testés en Preview
   - [ ] Tests unitaires passent (formatage, edge cases, N/A)

4. **UX** :
   - [ ] Manager comprend en 10 sec (validation manuelle)
   - [ ] Pas de "cas chelous" (0 données, période vide, N/A)
   - [ ] Responsive (iPhone SE → iPad)

5. **Intégration** :
   - [ ] P0.1.1 (intégrité) intégré dans statut global
   - [ ] P0.2 (navigation) fonctionne avec nouveau reporting
   - [ ] Pas de régression sur features existantes

6. **Documentation** :
   - [ ] Commentaires dans `ReportingEngine` (règles de calcul)
   - [ ] Exemples de formatage dans `FormatHelpers`
   - [ ] Mini-guide "Comment ajouter une nouvelle métrique" (1 page)

---

# NOTES TECHNIQUES

## Hypothèses explicites

1. **Coverage multi-jours** : 
   - Définition : nombre de jours calendaires uniques avec au moins 1 événement
   - Déjà implémenté dans `MetricsCalculator.computeDaysCovered()`

2. **Période précédente** :
   - Même durée que currentRange, immédiatement avant
   - Déjà implémenté dans `TimeRange.previousPeriod()`

3. **Occupation moyenne** :
   - Moyenne pondérée au temps (pas simple moyenne des buckets)
   - Déjà implémenté dans `MetricsCalculator.computeOccupancyMetrics()`

## Dépendances externes

- P0.1.1 : `DataIntegrityIssue`, `DataFlowSignal`, `DataCoverageWindow`
- P0.2 : `TimeRange.from(type:offsetDays:)`
- Nexus Design System : `.Colors`, `.Typography`, `.Spacing`

## Risques & mitigations

**Risk 1** : Formatage incohérent entre vues
- Mitigation : Centralisé dans FormatHelpers, tests unitaires

**Risk 2** : Ambiguïté N/A vs 0
- Mitigation : Règle stricte dans ReportingDelta (nil vs "0")

**Risk 3** : Performance (recalcul à chaque render)
- Mitigation : ViewModels utilisent computed properties (SwiftUI optimise)

---

# RÉSUMÉ EXÉCUTIF

## 4 tickets, 1 outcome : Reporting cohérent et exploitable

1. **Ticket 1** (fondations) : ReportingEngine + domain models + formatage
2. **Ticket 2** (UI) : Résumé rapide unifié
3. **Ticket 3** (UI) : Qualité + Détails (tables)
4. **Ticket 4** (UI) : Comparaison vs précédent (anti-ambiguïté)

**Total estimé** : 10-14h (1 dev) ou 6-8h (2 devs en parallèle sur tickets 2/3/4)

**Outcome vérifiable** : Manager ouvre app, navigue entre périodes, comprend tout en 10 sec sans ambiguïté.
