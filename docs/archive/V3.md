ğŸ“˜ LifeCount â€” Product Requirements Document (AI Context v3.4 Cursor-Optimized)
0) Context & Role

Role: Senior iOS Engineer / Lead Architect
Input: This PRD is the single source of truth.
Goal: produire du SwiftUI production-ready, architecture cohÃ©rente, data flow fiable.

Strict constraints

Ne pas halluciner de features.

Si ambigu, ask for clarification avant dâ€™implÃ©menter.

Core truth: LifeCount â‰  clicker app. Câ€™est une app dâ€™observability + synchronization + analytics alimentÃ©e par un external hardware event stream via Bluetooth (mode gateway).

1) Product Definition
What LifeCount is

Une app iOS qui ingÃ¨re des Ã©vÃ©nements +1 / -1 horodatÃ©s, Ã©mis par un compteur Bluetooth, et les publie vers Firestore (source de vÃ©ritÃ©). Elle expose :

Un Ã©cran principal unique: â€œDashboardâ€ pilotÃ© par un TimeRange selector (segmented control)

Today = LIVE mode

Last 7 / Last 30 / Year = Historical mode (KPIs + charts + data quality)

Gateway mode (core): lâ€™iPhone sur place reÃ§oit les signaux BLE et pousse vers le cloud pour multi-access.

Tools / Simulator (secondary): outil temporaire (dev + fallback), jamais le workflow primaire.

What LifeCount is NOT

Pas une â€œmanual counting appâ€ en primaire.

Pas un BI suite lourd en v1.

2) Responsibilities & Authority

Hardware (counter device):

Ã‰met des impulsions BLE delta = +1 / -1 avec mÃ©tadonnÃ©es minimales.

App (Gateway):

Maintient la connexion BLE, gÃ¨re reconnection, parse payload, vÃ©rifie integrity via sequenceNumber, push Firestore.

Backend (Firestore):

Source of truth finale : Ã©vÃ©nements + Ã©tat agrÃ©gÃ©.

Authority rules

Le hardware nâ€™est pas authoritative.

Le backend event history fait foi.

Le â€œlive counterâ€ UI est dÃ©rivÃ© de Firestore (CounterState et/ou reconstruction depuis Entry).

3) Tech Stack & Architecture

Swift 5.10+, SwiftUI, iOS 17+

MVVM + Observation Framework (@Observable)

Swift Concurrency (async/await)

Firebase Auth + Firestore listeners

DI lÃ©ger (Container/Factory), no third-party libs

Architecture rules

Views: â€œdumb UIâ€

ViewModels: state mapping + orchestration

Services: BLE + Firestore + Analytics

Models: struct Codable + Identifiable (immutable preferred)

4) External Counter Integration (BLE Gateway)
Transport

Primary: Bluetooth Low Energy (BLE) (scan â†’ connect â†’ subscribe/notify)

Gateway behavior (must)

Auto reconnect

State machine (scanning / connecting / connected / retry backoff)

Push events to Firestore in near real-time

Multi-access: autres admins/viewers consultent via cloud (Firestore)

Event payload (minimum)

Chaque event doit inclure :

delta âˆˆ {+1, -1}

timestamp (device timestamp ou gateway timestamp; voir rÃ¨gle ci-dessous)

sequenceNumber (mandatory)

deviceId (mandatory)

locationId (mandatory, ou dÃ©rivable via association deviceâ†’location)

Timestamp rule (clarifier dÃ¨s maintenant)

V1: si le device fournit un timestamp fiable â†’ utiliser device timestamp.

Sinon: gateway met timestamp = now (mais le PRD doit lâ€™acter explicitement).

Integrity / sequenceNumber (spec obligatoire)

sequenceNumber est monotonic per device (scope = deviceId).

Si sequenceNumber recule (device reboot) â†’ crÃ©er un flag â€œsequence resetâ€ (pas â€œmissing clicksâ€).

Si gap > 1 â†’ flag â€œmissing eventsâ€ et (optionnel v1) surface dans data quality.

5) Operational Day & Noon Reset

Tu veux un â€œresetâ€ Ã  midi. Pour Ã©viter les bugs, il faut formaliser :

Operational Day definition

OperationalDay est dÃ©fini par Location.timezone (IANA) + boundaryHour = 12 (12:00).

For any â€œtoday rangeâ€ in analytics:
start = most recent 12:00 in location TZ, end = now

â€œYesterdayâ€ = [start - 24h, start)

IMPORTANT

Le â€œnoon resetâ€ nâ€™est pas nÃ©cessairement un write destructeur.

V1 recommandÃ©e: le dashboard â€œTodayâ€ query/compute se base sur OperationalDay (filter), sans effacer lâ€™historique.

6) Data Model (Schema v3.4)

Tu gardes lâ€™esprit de v3.3 mais tu rÃ©introduis les champs indispensables pour gateway + audit.

// MARK: - Core Models

struct User: Identifiable, Codable {
    let id: String
    let email: String?
    let role: UserRole          // .admin, .viewer
    let createdAt: Date
}

struct Location: Identifiable, Codable {
    let id: String
    var name: String
    var maxCapacity: Int
    var timezone: String        // IANA, ex: "Europe/Paris"
    var operationalBoundaryHour: Int // v1: 12
}

/// Live aggregate state stored in Firestore
struct CounterState: Codable {
    var currentCount: Int
    var lastUpdated: Date
    var status: OccupancyStatus
    var lastEventAt: Date?
    var lastDeviceSeenAt: Date?     // optional convenience
}

/// Atomic event (source of truth)
struct Entry: Identifiable, Codable {
    let id: String
    let locationId: String
    let deviceId: String
    let userId: String?             // for manual/simulator audit
    let timestamp: Date
    let delta: Int                  // MUST be +1 or -1
    let source: EventSource         // .hardware, .manual, .simulator
    let sequenceNumber: Int         // mandatory (per device monotonic)
}

/// Device metadata
struct Device: Identifiable, Codable {
    let id: String                  // deviceId
    let locationId: String
    var name: String
    var lastHeartbeatAt: Date?
    var lastEventAt: Date?
    var isActive: Bool
}

// MARK: - Enums
enum OccupancyStatus: String, Codable { case ok, warning, full }
enum EventSource: String, Codable { case hardware, manual, simulator }
enum UserRole: String, Codable { case admin, viewer }


Invariant rules

Entry.delta must be exactly +1 or -1

CounterState.currentCount >= 0 (clamp)

status derived:

ok: <80%

warning: 80â€“99%

full: >=100%

7) Firestore responsibilities (critical to avoid split-brain)

Tu dois choisir qui maintient CounterState. Deux options; il faut en choisir une dans le PRD.

Option A (recommandÃ©e v1, simple): Gateway writes both

Gateway Ã©crit chaque Entry

Gateway met Ã  jour CounterState transactionnellement (ou via batched write) pour currentCount/lastEventAt/status

Option B (plus robuste long terme): Cloud Function aggregates

Gateway Ã©crit seulement Entry

Backend (Cloud Function) maintient CounterState

PRD decision (v3.4):

V1: Option A (moins dâ€™infra).

Mais: prÃ©voir extension future vers Option B.

Multi-gateway safety

V1: 1 gateway active par location (soft lock): Device.isActive / gatewaySessionId.

Si 2 gateways Ã©crivent: le systÃ¨me doit au minimum dÃ©tecter â€œconflictâ€ (data quality flag).

8) UI Features (v1)
A) Dashboard (single screen, TimeRange-driven)

Header (always)

Location picker (si multi-location)

TimeRange segmented: Today / 7d / 30d / Year

Live status pill (connected/scanning/offline)

Top-right button: Tools/Simulator (sheet or push)

A1) Today = LIVE mode

Must show

currentCount (primary)

maxCapacity, occupancy %, remaining places

OccupancyStatus semantic colors

Freshness:

Live â€¢ Xs from lastEventAt

Bluetooth state (Connected / Searching / Offline)

Interactions

Read-first.

Manual +/- nâ€™est pas sur lâ€™Ã©cran principal. Il est dans Tools/Simulator et role-gated.

Haptics

Light normal, Heavy error/limit.

A2) Last 7 / Last 30 / Year = Historical mode (Phase 4 target, but PRD-ready)

KPIs (must)

Total In, Total Out, Net

Peak occupancy (max count) + timestamp bucket

Peak flow (max entries per bucket) (optional but recommended)

Average occupancy (v1 approximation allowed, must be defined)

Charts

Swift Charts (bar/line)

Granularity:

Today = hour

7/30 = day

Year = month

Comparisons (Phase 4)

Show delta vs previous period:

today vs yesterday

last7 vs previous 7

last30 vs previous 30

year vs previous year

Data quality

Missing events gaps (sequenceNumber gaps)

Stale device detection

Overcrowding flag

B) Admin (operators)

Edit maxCapacity, timezone/boundaryHour

List devices (per location) with lastHeartbeatAt/lastEventAt

Manual override (creates Entry.source = .manual)

End day / reset (admin only) â€” si tu le gardes en v1, prÃ©ciser sâ€™il Ã©crit un â€œsnapshotâ€ plutÃ´t que supprimer.

C) Tools / Simulator (secondary)

Purpose

Dev/test sans hardware + fallback admin.

Rules

Emits Entry.source = .simulator

Must set locationId and deviceId (static acceptable v1)

Should be hidden or disabled for non-admin (and optionally DEBUG-only)

9) Folder Structure (Cursor-friendly)
LifeCount/
â”œâ”€â”€ App/
â”œâ”€â”€ Models/
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ BLEGatewayService.swift          // scan/connect/notify + state machine
â”‚   â”œâ”€â”€ CounterService.swift            // Firestore read/write + listeners
â”‚   â”œâ”€â”€ IntegrityService.swift          // sequenceNumber checks + flags
â”‚   â”œâ”€â”€ AnalyticsService.swift          // KPIs + bucketing + comparisons
â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ DashboardViewModel.swift         // orchestrates TimeRange
â”‚   â”œâ”€â”€ AdminViewModel.swift
â”‚   â”œâ”€â”€ ToolsViewModel.swift             // optional
â”œâ”€â”€ Views/
â”‚   â”œâ”€â”€ Dashboard/
â”‚   â”œâ”€â”€ Admin/
â”‚   â”œâ”€â”€ Tools/
â””â”€â”€ Utils/

10) Implementation Phases (explicit, to avoid scope creep)

Phase 1 (Refactor / IA)

Dashboard unique (TimeRange selector)

Tools/Simulator accessible top-right

Zero new KPIs, zero charts, zero comparisons (UI composition only)

Preserve build + existing metrics logic

Phase 2 (Phase 4)

Charts + bucketing + comparisons vs previous period

Data quality surface (stale/missing)

Average occupancy spec implemented (choose method)

11) Acceptance Criteria (Cursor â€œdefinition of doneâ€)

Build & UX

App launches without running selftests automatically (gated).

Dashboard is the default root screen.

Switching TimeRange updates content without navigation.

Tools/Simulator opens and can emit events (admin-only / debug).

Data

Entry writes include deviceId, locationId, sequenceNumber, delta.

sequenceNumber scope = per device; gaps flagged.

Operational day uses location timezone + boundaryHour=12.

12) Non-goals (explicit)

Pas de multi-gateway robust locking en v1 (soft lock only).

Pas dâ€™auto-reconciliation complexe (beyond flags).

Pas de BI avancÃ©. 